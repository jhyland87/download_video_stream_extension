{
  "version": 3,
  "sources": ["../src/types/index.ts", "../src/popup.ts"],
  "sourcesContent": ["/**\n * Type definitions for the Stream Video Saver extension\n */\n\n/**\n * Manifest object stored in history\n */\nexport interface Manifest {\n  id: string;\n  m3u8Url: string;\n  m3u8Content: string;\n  m3u8FileName: string;\n  title?: string; // Video title or page title\n  expectedSegments: string[];\n  capturedAt: string;\n}\n\n/**\n * Simplified manifest object returned to popup\n */\nexport interface ManifestSummary {\n  id: string;\n  fileName: string;\n  title?: string; // Video title or page title\n  url: string;\n  segmentCount: number;\n  capturedAt: string;\n}\n\n/**\n * Download format type\n */\nexport type DownloadFormat = 'zip';\n\n/**\n * Download status type\n */\nexport type DownloadStatus = 'starting' | 'downloading' | 'creating_zip' | 'complete' | 'cancelled';\n\n/**\n * Download progress information\n */\nexport interface DownloadProgress {\n  downloaded: number;\n  total: number;\n  status: DownloadStatus;\n}\n\n/**\n * Active download state\n */\nexport interface ActiveDownload {\n  manifestId: string;\n  format: DownloadFormat;\n  cancelled: boolean;\n  abortController: AbortController;\n  progress: DownloadProgress;\n}\n\n/**\n * Message actions sent between popup and background\n */\nexport type MessageAction =\n  | 'getStatus'\n  | 'getManifestData'\n  | 'clearManifest'\n  | 'startDownload'\n  | 'cancelDownload'\n  | 'getDownloadStatus'\n  | 'downloadProgress'\n  | 'downloadError'\n  | 'manifestCaptured'\n  | 'segmentDownloaded';\n\n/**\n * Base message interface\n */\nexport interface BaseMessage {\n  action: MessageAction;\n}\n\n/**\n * Get status message\n */\nexport interface GetStatusMessage extends BaseMessage {\n  action: 'getStatus';\n}\n\n/**\n * Get manifest data message\n */\nexport interface GetManifestDataMessage extends BaseMessage {\n  action: 'getManifestData';\n  manifestId: string;\n}\n\n/**\n * Clear manifest message\n */\nexport interface ClearManifestMessage extends BaseMessage {\n  action: 'clearManifest';\n  manifestId?: string;\n}\n\n/**\n * Start download message\n */\nexport interface StartDownloadMessage extends BaseMessage {\n  action: 'startDownload';\n  manifestId: string;\n  format: DownloadFormat;\n}\n\n/**\n * Cancel download message\n */\nexport interface CancelDownloadMessage extends BaseMessage {\n  action: 'cancelDownload';\n  downloadId: string;\n}\n\n/**\n * Get download status message\n */\nexport interface GetDownloadStatusMessage extends BaseMessage {\n  action: 'getDownloadStatus';\n}\n\n/**\n * Download progress message\n */\nexport interface DownloadProgressMessage extends BaseMessage {\n  action: 'downloadProgress';\n  downloadId: string;\n  downloaded: number;\n  total: number;\n  status: DownloadStatus;\n}\n\n/**\n * Download error message\n */\nexport interface DownloadErrorMessage extends BaseMessage {\n  action: 'downloadError';\n  downloadId: string;\n  error: string;\n}\n\n/**\n * Manifest captured message\n */\nexport interface ManifestCapturedMessage extends BaseMessage {\n  action: 'manifestCaptured';\n  manifestId: string;\n  fileName: string;\n  title?: string;\n  segmentCount: number;\n}\n\n/**\n * Segment downloaded message\n */\nexport interface SegmentDownloadedMessage extends BaseMessage {\n  action: 'segmentDownloaded';\n  segmentUrl: string;\n}\n\n/**\n * Union type for all messages\n */\nexport type ExtensionMessage =\n  | GetStatusMessage\n  | GetManifestDataMessage\n  | ClearManifestMessage\n  | StartDownloadMessage\n  | CancelDownloadMessage\n  | GetDownloadStatusMessage\n  | DownloadProgressMessage\n  | DownloadErrorMessage\n  | ManifestCapturedMessage\n  | SegmentDownloadedMessage;\n\n/**\n * Response for getStatus action\n */\nexport interface GetStatusResponse {\n  manifestHistory: ManifestSummary[];\n}\n\n/**\n * Response for getManifestData action\n */\nexport interface GetManifestDataResponse {\n  id?: string;\n  m3u8Url?: string;\n  m3u8Content?: string;\n  m3u8FileName?: string;\n  expectedSegments?: string[];\n  error?: string;\n}\n\n/**\n * Response for getDownloadStatus action\n */\nexport interface GetDownloadStatusResponse {\n  downloads: Array<{\n    downloadId: string;\n    manifestId: string;\n    format: DownloadFormat;\n    progress: DownloadProgress;\n  }>;\n}\n\n/**\n * Success response\n */\nexport interface SuccessResponse {\n  success: boolean;\n}\n\n/**\n * Union type for all responses\n */\nexport type ExtensionResponse =\n  | GetStatusResponse\n  | GetManifestDataResponse\n  | GetDownloadStatusResponse\n  | SuccessResponse\n  | { error: string };\n\n\n/**\n * Type guard to check if value is a valid message action\n */\nexport function isMessageAction(value: unknown): value is MessageAction {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  const validActions: MessageAction[] = [\n    'getStatus',\n    'getManifestData',\n    'clearManifest',\n    'startDownload',\n    'cancelDownload',\n    'getDownloadStatus',\n    'downloadProgress',\n    'downloadError',\n    'manifestCaptured',\n    'segmentDownloaded'\n  ];\n  return validActions.includes(value as MessageAction);\n}\n\n/**\n * Type guard to check if object is a GetStatusMessage\n */\nexport function isGetStatusMessage(message: unknown): message is GetStatusMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'getStatus';\n}\n\n/**\n * Type guard to check if object is a GetManifestDataMessage\n */\nexport function isGetManifestDataMessage(message: unknown): message is GetManifestDataMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'getManifestData' && typeof msg.manifestId === 'string';\n}\n\n/**\n * Type guard to check if object is a StartDownloadMessage\n */\nexport function isStartDownloadMessage(message: unknown): message is StartDownloadMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return (\n    msg.action === 'startDownload' &&\n    typeof msg.manifestId === 'string' &&\n    msg.format === 'zip'\n  );\n}\n\n/**\n * Type guard to check if object is a CancelDownloadMessage\n */\nexport function isCancelDownloadMessage(message: unknown): message is CancelDownloadMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'cancelDownload' && typeof msg.downloadId === 'string';\n}\n\n/**\n * Type guard to check if object is a ClearManifestMessage\n */\nexport function isClearManifestMessage(message: unknown): message is ClearManifestMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'clearManifest';\n}\n\n/**\n * Type guard to check if object is a GetDownloadStatusMessage\n */\nexport function isGetDownloadStatusMessage(message: unknown): message is GetDownloadStatusMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'getDownloadStatus';\n}\n\n/**\n * Type guard to check if object is a DownloadProgressMessage\n */\nexport function isDownloadProgressMessage(message: unknown): message is DownloadProgressMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return (\n    msg.action === 'downloadProgress' &&\n    typeof msg.downloadId === 'string' &&\n    typeof msg.downloaded === 'number' &&\n    typeof msg.total === 'number' &&\n    typeof msg.status === 'string'\n  );\n}\n\n/**\n * Type guard to check if object is a DownloadErrorMessage\n */\nexport function isDownloadErrorMessage(message: unknown): message is DownloadErrorMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return msg.action === 'downloadError' && typeof msg.error === 'string';\n}\n\n/**\n * Type guard to check if object is a ManifestCapturedMessage\n */\nexport function isManifestCapturedMessage(message: unknown): message is ManifestCapturedMessage {\n  if (typeof message !== 'object' || message === null) {\n    return false;\n  }\n  const msg = message as Record<string, unknown>;\n  return (\n    msg.action === 'manifestCaptured' &&\n    typeof msg.manifestId === 'string' &&\n    typeof msg.fileName === 'string' &&\n    typeof msg.segmentCount === 'number'\n  );\n}\n\n/**\n * Type guard to check if value is a non-null HTMLElement\n */\nexport function isHTMLElement(value: unknown): value is HTMLElement {\n  return value !== null && value instanceof HTMLElement;\n}\n\n/**\n * Type guard to check if value is a non-null HTMLDivElement\n */\nexport function isHTMLDivElement(value: unknown): value is HTMLDivElement {\n  return value !== null && value instanceof HTMLDivElement;\n}\n\n/**\n * Type guard to check if value is a non-null HTMLButtonElement\n */\nexport function isHTMLButtonElement(value: unknown): value is HTMLButtonElement {\n  return value !== null && value instanceof HTMLButtonElement;\n}\n\n", "/**\n * @fileoverview Popup script for UI interaction and user interface management.\n * This script handles:\n * - Rendering manifest history\n * - Initiating ZIP downloads\n * - Displaying download progress\n * - Managing user interactions (clear, cancel, download)\n * - Communicating with background script\n */\n\nimport type {\n  ManifestSummary,\n  DownloadFormat,\n  ExtensionMessage,\n  ExtensionResponse,\n  GetStatusResponse,\n  GetDownloadStatusResponse,\n  DownloadProgressMessage,\n  DownloadErrorMessage,\n  ManifestCapturedMessage\n} from './types/index.js';\nimport {\n  isHTMLElement,\n  isHTMLDivElement,\n  isHTMLButtonElement\n} from './types/index.js';\n\n// CRITICAL: This should appear in console immediately when script loads\nconsole.log('[Stream Video Saver] popup.ts loaded - script is executing');\n\n// Error handler to catch script loading errors\nwindow.addEventListener('error', (e: ErrorEvent) => {\n  console.error(`[Stream Video Saver] Script error: ${e.message} in ${e.filename ?? 'unknown'}:${e.lineno ?? 'unknown'}`);\n  const debugInfo = document.getElementById('debugInfo');\n  if (debugInfo) {\n    debugInfo.textContent = 'ERROR: ' + e.message + ' in ' + (e.filename ?? 'unknown');\n    debugInfo.style.color = '#d32f2f';\n    debugInfo.style.background = '#ffebee';\n  }\n}, true);\n\n// Try to update debug info immediately (before DOMContentLoaded)\ntry {\n  const debugInfo = document.getElementById('debugInfo');\n  if (debugInfo) {\n    debugInfo.textContent = 'Debug: Script loaded! Waiting for DOM...';\n    debugInfo.style.color = '#2196f3';\n    console.log('[Stream Video Saver] Debug info element found and updated');\n  } else {\n    console.error('[Stream Video Saver] Debug info element NOT found!');\n  }\n} catch (error) {\n  console.error('[Stream Video Saver] Error updating debug info:', error);\n}\n\n// Also try updating status immediately\ntry {\n  const statusDiv = document.getElementById('status');\n  if (statusDiv) {\n    statusDiv.textContent = 'Script loaded - initializing...';\n    console.log('[Stream Video Saver] Status div found and updated');\n  } else {\n    console.error('[Stream Video Saver] Status div NOT found!');\n  }\n} catch (error) {\n  console.error('[Stream Video Saver] Error updating status:', error);\n}\n\n// Interval ID for periodic status updates\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nlet statusInterval: ReturnType<typeof setInterval> | null = null;\n\n/**\n * Initializes the popup when DOM is ready.\n * Sets up event listeners, renders manifest history, and checks for ongoing downloads.\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('[Stream Video Saver] DOMContentLoaded fired');\n\n  // Immediate test - update status div to show script is running\n  const statusDiv = document.getElementById('status');\n  const debugInfo = document.getElementById('debugInfo');\n\n  if (statusDiv) {\n    statusDiv.textContent = 'Popup script loaded - checking for manifests...';\n    statusDiv.className = 'status';\n  }\n\n  if (debugInfo) {\n    debugInfo.style.display = 'block';\n    debugInfo.textContent = 'Debug: DOMContentLoaded fired, initializing...';\n    debugInfo.style.color = '#2196f3';\n  }\n\n  const manifestHistoryDiv = document.getElementById('manifestHistory');\n  const clearAllBtn = document.getElementById('clearAllBtn');\n  const progressDiv = document.getElementById('progress');\n  const progressFill = document.getElementById('progressFill');\n  const progressInfo = document.getElementById('progressInfo');\n  const errorDiv = document.getElementById('error');\n  const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');\n\n  console.log('[Stream Video Saver] DOM elements found:', {\n    statusDiv: !!statusDiv,\n    manifestHistoryDiv: !!manifestHistoryDiv,\n    clearAllBtn: !!clearAllBtn,\n    progressDiv: !!progressDiv,\n    progressFill: !!progressFill,\n    progressInfo: !!progressInfo,\n    errorDiv: !!errorDiv\n  });\n\n  if (!statusDiv || !manifestHistoryDiv) {\n    console.error('[Stream Video Saver] CRITICAL: Required DOM elements not found!');\n    if (statusDiv) {\n      statusDiv.textContent = 'ERROR: DOM elements not found!';\n      statusDiv.style.background = '#ffebee';\n      statusDiv.style.color = '#c62828';\n    }\n    return;\n  }\n\n  let selectedManifestId: string | null = null;\n  let eventListenerAttached = false;\n  let activeDownloadId: string | null = null; // Track active download ID\n\n  // Attach event listeners using event delegation (only once)\n  if (!eventListenerAttached) {\n    manifestHistoryDiv.addEventListener('click', (e: MouseEvent) => {\n      const target = e.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n      const manifestId = target.getAttribute('data-manifest-id');\n      if (!manifestId) {\n        return;\n      }\n\n      if (target.classList.contains('btn-clear-manifest')) {\n        clearManifest(manifestId);\n      } else if (target.classList.contains('btn-download-zip')) {\n        downloadManifest(manifestId, 'zip');\n      }\n    });\n    eventListenerAttached = true;\n  }\n\n  // Cancel button click handler\n  if (cancelDownloadBtn) {\n    cancelDownloadBtn.addEventListener('click', () => {\n      cancelDownload();\n    });\n  }\n\n  /**\n   * Renders the list of captured manifests in the UI.\n   * Displays manifest information including filename, segment count, and capture time.\n   * Shows empty state if no manifests are available.\n   */\n  function renderManifestHistory(manifests: ManifestSummary[]): void {\n    console.log(`[Stream Video Saver] renderManifestHistory called with ${manifests?.length ?? 0} manifests`);\n\n    if (!manifestHistoryDiv || !statusDiv || !clearAllBtn) {\n      console.error('[Stream Video Saver] DOM elements not found!');\n      return;\n    }\n\n    if (!manifests || manifests.length === 0) {\n      manifestHistoryDiv.innerHTML = '';\n      statusDiv.textContent = 'Monitoring for video streams...';\n      statusDiv.className = 'status';\n      clearAllBtn.style.display = 'none';\n      console.log('[Stream Video Saver] Rendered empty state');\n      return;\n    }\n\n    statusDiv.textContent = `${manifests.length} manifest${manifests.length > 1 ? 's' : ''} captured`;\n    statusDiv.className = 'status active';\n    clearAllBtn.style.display = 'block';\n\n    const html = manifests.map((manifest) => {\n      const date = new Date(manifest.capturedAt);\n      const timeStr = date.toLocaleTimeString();\n\n      // Escape HTML to prevent XSS\n      const escapeHtml = (text: string): string => {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n      };\n\n      // Use title if available, otherwise fall back to fileName\n      const displayTitle = manifest.title || manifest.fileName;\n\n      return `\n        <div class=\"manifest-item\" data-manifest-id=\"${escapeHtml(manifest.id)}\">\n          <div class=\"manifest-item-header\">\n            <span>${escapeHtml(displayTitle)}</span>\n            <button class=\"btn-small secondary btn-clear-manifest\" data-manifest-id=\"${escapeHtml(manifest.id)}\" style=\"padding: 2px 6px; font-size: 10px;\">\u00D7</button>\n          </div>\n          <div class=\"manifest-item-name\">${escapeHtml(displayTitle)}</div>\n          <div class=\"manifest-item-info\">\n            ${manifest.segmentCount} segments \u2022 Captured at ${escapeHtml(timeStr)}\n          </div>\n          <div class=\"manifest-item-actions\">\n            <button class=\"button primary btn-download-zip\" data-manifest-id=\"${escapeHtml(manifest.id)}\" style=\"font-size: 11px; padding: 6px;\">Download ZIP</button>\n          </div>\n        </div>\n      `;\n    }).join('');\n\n    manifestHistoryDiv.innerHTML = html;\n    console.log(`[Stream Video Saver] Rendered ${manifests.length} manifest items`);\n  }\n\n  /**\n   * Updates the manifest status by requesting current state from background script.\n   * Fetches manifest history and re-renders the UI.\n   */\n  function updateStatus(): void {\n    console.log('[Stream Video Saver] updateStatus() called - sending getStatus message');\n\n    try {\n      chrome.runtime.sendMessage({ action: 'getStatus' } as ExtensionMessage, (response: ExtensionResponse) => {\n        console.log('[Stream Video Saver] getStatus callback invoked');\n        console.log(`[Stream Video Saver] chrome.runtime.lastError: ${chrome.runtime.lastError?.message ?? 'none'}`);\n        console.log(`[Stream Video Saver] response:`, response);\n\n        if (chrome.runtime.lastError) {\n          console.error('[Stream Video Saver] Error getting status:', chrome.runtime.lastError);\n          renderManifestHistory([]);\n          return;\n        }\n\n        if (response && 'manifestHistory' in response) {\n          const statusResponse = response as GetStatusResponse;\n          console.log(`[Stream Video Saver] Rendering ${statusResponse.manifestHistory.length} manifests`);\n          console.log(`[Stream Video Saver] Manifest data:`, statusResponse.manifestHistory);\n          renderManifestHistory(statusResponse.manifestHistory);\n        } else {\n          console.log('[Stream Video Saver] No manifests in response, rendering empty list');\n          console.log('[Stream Video Saver] Full response object:', response);\n          renderManifestHistory([]);\n        }\n      });\n    } catch (error) {\n      console.error('[Stream Video Saver] Exception in updateStatus:', error);\n      renderManifestHistory([]);\n    }\n  }\n\n  /**\n   * Initiates download of a specific manifest as a ZIP file.\n   * Sends request to background script for background download.\n   */\n  async function downloadManifest(manifestId: string, _format: DownloadFormat): Promise<void> {\n    if (!isHTMLDivElement(progressDiv) || !isHTMLElement(progressFill) || !isHTMLElement(progressInfo) || !isHTMLDivElement(errorDiv)) {\n      console.error('[Stream Video Saver] Required DOM elements not found');\n      return;\n    }\n\n    // Prevent double-clicks\n    if (selectedManifestId === manifestId && progressDiv.classList.contains('active')) {\n      console.log(`[Stream Video Saver] Download already in progress for manifest ${manifestId}, ignoring duplicate click`);\n      return;\n    }\n\n    selectedManifestId = manifestId;\n    errorDiv.classList.remove('show');\n    progressDiv.classList.add('active');\n    progressFill.style.width = '0%';\n    progressFill.textContent = '0%';\n    progressInfo.textContent = 'Starting download...';\n    if (isHTMLButtonElement(cancelDownloadBtn)) {\n      cancelDownloadBtn.style.display = 'block';\n    }\n\n    // Send download request to background script\n    chrome.runtime.sendMessage({\n      action: 'startDownload',\n      manifestId: manifestId,\n      format: 'zip'\n    } as ExtensionMessage, (response: ExtensionResponse) => {\n      if (!isHTMLDivElement(progressDiv)) return;\n      if (chrome.runtime.lastError) {\n        const errorMsg = chrome.runtime.lastError.message || 'Unknown error';\n        showError(errorMsg);\n        progressDiv.classList.remove('active');\n        if (isHTMLButtonElement(cancelDownloadBtn)) {\n          cancelDownloadBtn.style.display = 'none';\n        }\n      } else if (response && 'error' in response) {\n        const errorMsg = response.error || 'Unknown error';\n        showError(errorMsg);\n        progressDiv.classList.remove('active');\n        if (isHTMLButtonElement(cancelDownloadBtn)) {\n          cancelDownloadBtn.style.display = 'none';\n        }\n      }\n      // Download will continue in background, progress updates will come via messages\n    });\n  }\n\n  /**\n   * Cancels the currently active download.\n   * Sends cancel request to background script and updates UI.\n   */\n  function cancelDownload(): void {\n    if (!isHTMLDivElement(progressDiv) || !isHTMLElement(progressInfo)) return;\n    if (activeDownloadId) {\n      chrome.runtime.sendMessage({\n        action: 'cancelDownload',\n        downloadId: activeDownloadId\n      } as ExtensionMessage, () => {\n        activeDownloadId = null;\n        progressDiv.classList.remove('active');\n        progressInfo.textContent = 'Download cancelled';\n        if (isHTMLButtonElement(cancelDownloadBtn)) {\n          cancelDownloadBtn.style.display = 'none';\n        }\n      });\n    }\n  }\n\n  /**\n   * Clears a specific manifest from the history.\n   * Sends clear request to background script and refreshes the UI.\n   */\n  function clearManifest(manifestId: string): void {\n    chrome.runtime.sendMessage({ action: 'clearManifest', manifestId: manifestId } as ExtensionMessage, (response: ExtensionResponse) => {\n      if (chrome.runtime.lastError) {\n        const errorMsg = chrome.runtime.lastError.message || 'Unknown error';\n        showError(errorMsg);\n        return;\n      }\n      if (response && 'success' in response) {\n        updateStatus();\n      }\n    });\n  }\n\n  // Clear all manifests\n  if (clearAllBtn) {\n    clearAllBtn.addEventListener('click', () => {\n      chrome.runtime.sendMessage({ action: 'clearManifest' } as ExtensionMessage, (response: ExtensionResponse) => {\n        if (chrome.runtime.lastError) {\n          const errorMsg = chrome.runtime.lastError.message || 'Unknown error';\n        showError(errorMsg);\n          return;\n        }\n        if (response && 'success' in response) {\n          updateStatus();\n        }\n      });\n    });\n  }\n\n\n  /**\n   * Message listener for receiving updates from background script.\n   * Handles download progress updates, download errors, and manifest capture notifications.\n   */\n  chrome.runtime.onMessage.addListener((message: ExtensionMessage) => {\n    if (message.action === 'downloadProgress') {\n      const progressMessage = message as DownloadProgressMessage;\n      activeDownloadId = progressMessage.downloadId;\n      const percent = Math.round((progressMessage.downloaded / progressMessage.total) * 100);\n      if (isHTMLElement(progressFill)) {\n        progressFill.style.width = percent + '%';\n        progressFill.textContent = `${percent}%`;\n      }\n\n      if (progressMessage.status === 'creating_zip') {\n        if (isHTMLElement(progressInfo)) {\n          progressInfo.textContent = 'Creating ZIP file...';\n        }\n      } else if (progressMessage.status === 'complete') {\n        if (isHTMLElement(progressInfo)) {\n          progressInfo.textContent = 'Download complete!';\n        }\n        if (isHTMLDivElement(progressDiv)) {\n          setTimeout(() => {\n            progressDiv.classList.remove('active');\n            activeDownloadId = null;\n          }, 2000);\n        }\n      } else if (progressMessage.status === 'cancelled') {\n        if (isHTMLElement(progressInfo)) {\n          progressInfo.textContent = 'Download cancelled';\n        }\n        if (isHTMLDivElement(progressDiv)) {\n          setTimeout(() => {\n            progressDiv.classList.remove('active');\n            activeDownloadId = null;\n          }, 2000);\n        }\n      } else {\n        if (isHTMLElement(progressInfo)) {\n          progressInfo.textContent = `Downloaded ${progressMessage.downloaded} of ${progressMessage.total} segments`;\n        }\n      }\n      if (isHTMLDivElement(progressDiv)) {\n        progressDiv.classList.add('active');\n      }\n      // Show cancel button when download is active\n      if (isHTMLButtonElement(cancelDownloadBtn)) {\n        if (progressMessage.status !== 'complete' && progressMessage.status !== 'cancelled') {\n          cancelDownloadBtn.style.display = 'block';\n        } else {\n          cancelDownloadBtn.style.display = 'none';\n        }\n      }\n    } else if (message.action === 'downloadError') {\n      const errorMessage = message as DownloadErrorMessage;\n      showError(errorMessage.error || 'Download failed');\n      if (isHTMLDivElement(progressDiv)) {\n        progressDiv.classList.remove('active');\n      }\n      activeDownloadId = null;\n    } else if (message.action === 'manifestCaptured') {\n      // New manifest detected\n      const capturedMessage = message as ManifestCapturedMessage;\n      console.log(`[Stream Video Saver] Manifest captured: ${capturedMessage.fileName}`);\n      updateStatus();\n    }\n  });\n\n  /**\n   * Displays an error message in the UI.\n   */\n  function showError(message: string): void {\n    if (isHTMLDivElement(errorDiv)) {\n      errorDiv.textContent = 'Error: ' + message;\n      errorDiv.classList.add('show');\n    }\n  }\n\n  // parseM3U8 function removed - no longer needed since MP4 conversion is removed\n\n  // Verify chrome.runtime is available\n  if (typeof chrome === 'undefined' || !chrome.runtime) {\n    console.error('[Stream Video Saver] CRITICAL: chrome.runtime is not available!');\n    if (statusDiv) {\n      statusDiv.textContent = 'ERROR: Chrome runtime not available!';\n      statusDiv.style.background = '#ffebee';\n      statusDiv.style.color = '#c62828';\n    }\n    return;\n  }\n\n  // Test: Try to get status immediately to verify communication works\n  console.log('[Stream Video Saver] Testing message passing...');\n  console.log('[Stream Video Saver] chrome.runtime available:', !!chrome.runtime);\n  console.log('[Stream Video Saver] chrome.runtime.sendMessage available:', typeof chrome.runtime.sendMessage === 'function');\n\n  chrome.runtime.sendMessage({ action: 'getStatus' } as ExtensionMessage, (response: ExtensionResponse) => {\n    console.log('[Stream Video Saver] TEST - Response received:', response);\n    console.log('[Stream Video Saver] TEST - Last error:', chrome.runtime.lastError);\n    if (chrome.runtime.lastError) {\n      console.error('[Stream Video Saver] TEST - Error:', chrome.runtime.lastError.message);\n      if (statusDiv) {\n        statusDiv.textContent = 'ERROR: ' + chrome.runtime.lastError.message;\n        statusDiv.style.background = '#ffebee';\n        statusDiv.style.color = '#c62828';\n      }\n      return;\n    }\n    if (response && 'manifestHistory' in response) {\n      const statusResponse = response as GetStatusResponse;\n      console.log(`[Stream Video Saver] TEST - Found ${statusResponse.manifestHistory.length} manifests`);\n      if (debugInfo) {\n        debugInfo.textContent = `Debug: Found ${statusResponse.manifestHistory.length} manifests in response`;\n        debugInfo.style.color = '#4caf50';\n      }\n      renderManifestHistory(statusResponse.manifestHistory);\n    } else {\n      console.log('[Stream Video Saver] TEST - No manifests or invalid response');\n      if (debugInfo) {\n        debugInfo.textContent = 'Debug: No manifests in response: ' + JSON.stringify(response);\n        debugInfo.style.color = '#ff9800';\n      }\n      if (statusDiv) {\n        statusDiv.textContent = 'No manifests found';\n      }\n    }\n  });\n\n  // Check for ongoing downloads when popup opens\n  chrome.runtime.sendMessage({ action: 'getDownloadStatus' } as ExtensionMessage, (response: ExtensionResponse) => {\n    if (response && 'downloads' in response) {\n      const statusResponse = response as GetDownloadStatusResponse;\n      if (statusResponse.downloads && statusResponse.downloads.length > 0) {\n        const download = statusResponse.downloads[0]; // Show first active download\n        activeDownloadId = download.downloadId;\n        if (isHTMLDivElement(progressDiv) && isHTMLElement(progressFill)) {\n          progressDiv.classList.add('active');\n          const percent = Math.round((download.progress.downloaded / download.progress.total) * 100);\n          progressFill.style.width = percent + '%';\n          progressFill.textContent = `${percent}%`;\n        }\n        if (isHTMLElement(progressInfo)) {\n          if (download.progress.status === 'creating_zip') {\n            progressInfo.textContent = 'Creating ZIP file...';\n          } else {\n            progressInfo.textContent = `Downloaded ${download.progress.downloaded} of ${download.progress.total} segments`;\n          }\n        }\n        if (isHTMLButtonElement(cancelDownloadBtn) && download.progress.status !== 'complete' && download.progress.status !== 'cancelled') {\n          cancelDownloadBtn.style.display = 'block';\n        }\n      }\n    }\n  });\n\n  // Initial status update\n  console.log('[Stream Video Saver] Calling initial updateStatus()');\n  updateStatus();\n  // Update status every 5 seconds to check for new manifests (reduced frequency to avoid excessive updates)\n  console.log('[Stream Video Saver] Setting up interval to update status every 5 seconds');\n  statusInterval = setInterval(updateStatus, 5000);\n  console.log('[Stream Video Saver] Popup initialization complete');\n});\n\n"],
  "mappings": "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",
  "names": []
}
