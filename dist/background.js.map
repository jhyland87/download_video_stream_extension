{
  "version": 3,
  "sources": ["../src/background.ts"],
  "sourcesContent": ["/**\n * @fileoverview Background service worker for managing state and downloads.\n * This script runs in the background and handles:\n * - Monitoring network requests for m3u8 files\n * - Storing captured manifests\n * - Managing background downloads that continue even when popup is closed\n * - Processing ZIP file creation\n */\n\n// Types are available via global.d.ts\n// JSZip will be loaded via importScripts in the bundled output\n\n/**\n * Regular expression pattern to match m3u8 files in URLs.\n * Matches any .m3u8 file including master.m3u8, index-f*-v*-a*.m3u8, etc.\n */\nconst M3U8_PATTERN = /\\.m3u8(\\?|$)/i;\n\n/**\n * Array of captured manifest objects.\n */\nlet manifestHistory: Manifest[] = [];\n\n/**\n * Map tracking active downloads.\n */\nlet activeDownloads = new Map<string, ActiveDownload>();\n\n/**\n * Generates a unique ID for each manifest using timestamp and random string.\n * @returns A unique identifier combining timestamp and random characters\n */\nfunction generateManifestId(): string {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n\nconsole.log('[Stream Video Saver] Background script loaded');\nconsole.log('[Stream Video Saver] Starting continuous monitoring for m3u8 files...');\n\n// Start monitoring automatically when extension loads\nchrome.webRequest.onCompleted.addListener(\n  (details: chrome.webRequest.WebResponseDetails) => {\n    handleRequestCompleted(details as unknown as chrome.webRequest.WebRequestBodyDetails);\n  },\n  { urls: ['<all_urls>'] },\n  ['responseHeaders']\n);\n\nconsole.log('[Stream Video Saver] \u2705 Continuous monitoring active');\n\n/**\n * Message handler for communication with popup and content scripts.\n * Handles various actions: getStatus, getManifestData, clearManifest, startDownload, cancelDownload, getDownloadStatus\n */\nchrome.runtime.onMessage.addListener((\n  message: ExtensionMessage,\n  _sender: chrome.runtime.MessageSender,\n  sendResponse: (response: ExtensionResponse) => void\n): boolean => {\n  console.log(`[Stream Video Saver] Background received message: ${message.action}`);\n\n  if (message.action === 'getStatus') {\n    // Filter out manifests with no segments and remove duplicates\n    // Group by URL (without query params) and keep only the most recent one\n    const seen = new Map<string, ManifestSummary & { urlKey: string }>();\n    const filtered = manifestHistory\n      .filter((m) => m.expectedSegments.length > 0) // Only include manifests with segments\n      .map((m) => ({\n        id: m.id,\n        fileName: m.m3u8FileName,\n        title: m.title,\n        url: m.m3u8Url,\n        segmentCount: m.expectedSegments.length,\n        capturedAt: m.capturedAt,\n        urlKey: m.m3u8Url.split('?')[0] // URL without query params for deduplication\n      }))\n      .filter((m) => {\n        // Keep only the most recent manifest for each unique URL\n        const existing = seen.get(m.urlKey);\n        if (!existing || new Date(m.capturedAt) > new Date(existing.capturedAt)) {\n          if (existing) {\n            // Remove the older one\n            seen.delete(m.urlKey);\n          }\n          seen.set(m.urlKey, m);\n          return true;\n        }\n        return false;\n      })\n      .map((m) => ({\n        id: m.id,\n        fileName: m.fileName,\n        title: m.title,\n        url: m.url,\n        segmentCount: m.segmentCount,\n        capturedAt: m.capturedAt\n      }))\n      // Sort by capturedAt in descending order (most recent first)\n      .sort((a, b) => new Date(b.capturedAt).getTime() - new Date(a.capturedAt).getTime());\n\n    console.log(`[Stream Video Saver] getStatus: returning ${filtered.length} manifests (filtered from ${manifestHistory.length} total, removed ${manifestHistory.length - filtered.length} with no segments or duplicates)`);\n    console.log(`[Stream Video Saver] Manifest IDs: ${filtered.map((m) => m.id).join(', ')}`);\n    const response: GetStatusResponse = {\n      manifestHistory: filtered\n    };\n    sendResponse(response);\n    return true; // Indicate we will send a response\n  } else if (message.action === 'getManifestData') {\n    // Get data for a specific manifest by ID\n    const manifest = manifestHistory.find((m) => m.id === message.manifestId);\n    if (manifest) {\n      const response: GetManifestDataResponse = {\n        id: manifest.id,\n        m3u8Url: manifest.m3u8Url,\n        m3u8Content: manifest.m3u8Content,\n        m3u8FileName: manifest.m3u8FileName,\n        expectedSegments: manifest.expectedSegments\n      };\n      sendResponse(response);\n    } else {\n      sendResponse({ error: 'Manifest not found' });\n    }\n  } else if (message.action === 'clearManifest') {\n    // Clear a specific manifest or all manifests\n    if (message.manifestId) {\n      manifestHistory = manifestHistory.filter((m) => m.id !== message.manifestId);\n      console.log(`[Stream Video Saver] \u2705 Manifest cleared: ${message.manifestId}. Remaining: ${manifestHistory.length}`);\n    } else {\n      manifestHistory = [];\n      console.log('[Stream Video Saver] \u2705 All manifests cleared');\n    }\n    const response: SuccessResponse = { success: true };\n    sendResponse(response);\n  } else if (message.action === 'segmentDownloaded') {\n    // Track that a segment was downloaded (for progress tracking only)\n    const segmentUrl = message.segmentUrl;\n    console.log(`[Stream Video Saver] \uD83D\uDCE5 Segment downloaded: ${segmentUrl}`);\n\n    // Find the manifest this segment belongs to (if we track it)\n    // For now, just acknowledge\n    const response: SuccessResponse = {\n      success: true\n    };\n    sendResponse(response);\n  } else if (message.action === 'startDownload') {\n    // Start a download in the background\n    const { manifestId, format } = message;\n    startDownload(manifestId, format).catch((error) => {\n      console.error('[Stream Video Saver] Error starting download:', error);\n    });\n    const response: SuccessResponse = { success: true };\n    sendResponse(response);\n  } else if (message.action === 'cancelDownload') {\n    // Cancel an ongoing download\n    const { downloadId } = message;\n    cancelDownload(downloadId);\n    const response: SuccessResponse = { success: true };\n    sendResponse(response);\n  } else if (message.action === 'getDownloadStatus') {\n    // Get status of ongoing downloads\n    const statuses = Array.from(activeDownloads.entries()).map(([id, download]) => ({\n      downloadId: id,\n      manifestId: download.manifestId,\n      format: download.format,\n      progress: download.progress || { downloaded: 0, total: 0, status: 'starting' as DownloadStatus }\n    }));\n    const response: GetDownloadStatusResponse = { downloads: statuses };\n    sendResponse(response);\n  }\n  return true;\n});\n\n/**\n * Parses an m3u8 playlist file and extracts segment URLs.\n * Handles absolute URLs, relative URLs, and URLs with query parameters.\n * @param content - The m3u8 file content as a string\n * @param baseUrl - The base URL of the m3u8 file (used for resolving relative URLs)\n * @returns Array of absolute segment URLs\n */\nfunction parseM3U8(content: string, baseUrl: string): string[] {\n  console.log(`[Stream Video Saver] Parsing m3u8, baseUrl: ${baseUrl}`);\n  const lines = content.split('\\n');\n  const segmentUrls: string[] = [];\n\n  if (!baseUrl) {\n    console.warn('[Stream Video Saver] No baseUrl provided for parsing');\n    return segmentUrls;\n  }\n\n  // Parse base URL - handle query parameters\n  const baseUrlWithoutQuery = baseUrl.split('?')[0];\n  const base = new URL(baseUrlWithoutQuery);\n  const basePath = base.pathname.substring(0, base.pathname.lastIndexOf('/') + 1);\n  console.log(`[Stream Video Saver] Base origin: ${base.origin}`);\n  console.log(`[Stream Video Saver] Base path: ${basePath}`);\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Skip empty lines and comments\n    if (!line || line.startsWith('#')) {\n      continue;\n    }\n\n    // This is a URL line (any non-comment, non-empty line)\n    // Could be a segment file (.ts, .m4s, etc.) or another m3u8 file\n    if (line && !line.startsWith('#')) {\n      let segmentUrl: string;\n\n      // Handle absolute URLs (with or without query parameters)\n      if (line.startsWith('http://') || line.startsWith('https://')) {\n        segmentUrl = line;\n      } else if (line.startsWith('/')) {\n        // Absolute path from root\n        segmentUrl = base.origin + line;\n      } else {\n        // Relative path - combine with base path\n        segmentUrl = base.origin + basePath + line;\n      }\n\n      // Only log first few segments to avoid console spam\n      if (segmentUrls.length < 3) {\n        console.log(`[Stream Video Saver] Found segment/manifest: ${line} -> ${segmentUrl}`);\n      }\n      segmentUrls.push(segmentUrl);\n    }\n  }\n\n  console.log(`[Stream Video Saver] Total segments/manifests parsed: ${segmentUrls.length}`);\n  return segmentUrls;\n}\n\n/**\n * Parses an m3u8 playlist file and extracts initialization segment URLs from #EXT-X-MAP tags.\n * Handles absolute URLs, relative URLs, and URLs with query parameters.\n * @param content - The m3u8 file content as a string\n * @param baseUrl - The base URL of the m3u8 file (used for resolving relative URLs)\n * @returns Array of absolute initialization segment URLs\n */\nfunction parseInitSegments(content: string, baseUrl: string): string[] {\n  console.log(`[Stream Video Saver] Parsing m3u8 for init segments, baseUrl: ${baseUrl}`);\n  const lines = content.split('\\n');\n  const initSegmentUrls: string[] = [];\n\n  if (!baseUrl) {\n    console.warn('[Stream Video Saver] No baseUrl provided for parsing init segments');\n    return initSegmentUrls;\n  }\n\n  // Parse base URL - handle query parameters\n  const baseUrlWithoutQuery = baseUrl.split('?')[0];\n  const base = new URL(baseUrlWithoutQuery);\n  const basePath = base.pathname.substring(0, base.pathname.lastIndexOf('/') + 1);\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Look for #EXT-X-MAP tag\n    if (line.startsWith('#EXT-X-MAP:')) {\n      // Extract URI from the tag\n      // Format: #EXT-X-MAP:URI=\"path/to/init.mp4\"\n      const uriMatch = line.match(/URI=\"([^\"]+)\"/);\n      if (uriMatch && uriMatch[1]) {\n        const uri = uriMatch[1];\n        let initSegmentUrl: string;\n\n        // Handle absolute URLs (with or without query parameters)\n        if (uri.startsWith('http://') || uri.startsWith('https://')) {\n          initSegmentUrl = uri;\n        } else if (uri.startsWith('/')) {\n          // Absolute path from root\n          initSegmentUrl = base.origin + uri;\n        } else {\n          // Relative path - combine with base path\n          initSegmentUrl = base.origin + basePath + uri;\n        }\n\n        console.log(`[Stream Video Saver] Found init segment: ${uri} -> ${initSegmentUrl}`);\n        initSegmentUrls.push(initSegmentUrl);\n      }\n    }\n  }\n\n  console.log(`[Stream Video Saver] Total init segments parsed: ${initSegmentUrls.length}`);\n  return initSegmentUrls;\n}\n\n/**\n * Set of URLs that have been recently processed to prevent duplicate processing.\n */\nconst recentlyProcessed = new Set<string>();\n\n/**\n * Cooldown period in milliseconds before a URL can be processed again.\n */\nconst PROCESSING_COOLDOWN = 5000; // 5 seconds cooldown for same URL\n\n/**\n * Handles completed network requests and captures m3u8 files.\n * Filters for VOD playlists only, fetches content, parses segments, and stores in manifest history.\n * @param details - Details about the completed request\n */\nasync function handleRequestCompleted(details: chrome.webRequest.WebRequestBodyDetails): Promise<void> {\n  const url = details.url;\n\n  // Check if it's an m3u8 file\n  if (!M3U8_PATTERN.test(url)) {\n    return;\n  }\n\n  const urlWithoutQuery = url.split('?')[0];\n\n  // Skip if we've processed this URL recently (cooldown period)\n  if (recentlyProcessed.has(urlWithoutQuery)) {\n    return; // Silently skip - already processed recently\n  }\n\n  // Check if we already have this exact manifest in history\n  const existingManifest = manifestHistory.find((m) => {\n    const existingUrlWithoutQuery = m.m3u8Url.split('?')[0];\n    return existingUrlWithoutQuery === urlWithoutQuery;\n  });\n\n  if (existingManifest) {\n    // Already have it, skip processing\n    return;\n  }\n\n  // Mark as being processed\n  recentlyProcessed.add(urlWithoutQuery);\n\n  // Remove from cooldown set after cooldown period\n  setTimeout(() => {\n    recentlyProcessed.delete(urlWithoutQuery);\n  }, PROCESSING_COOLDOWN);\n\n  console.log(`[Stream Video Saver] \u2713 M3U8 file detected (new): ${url}`);\n\n  try {\n    // Fetch the m3u8 content using the extension's context (bypasses CORS)\n    console.log(`[Stream Video Saver] Fetching m3u8 content from: ${url}`);\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(`[Stream Video Saver] Failed to fetch m3u8: ${response.status} ${response.statusText}`);\n      return;\n    }\n\n    const text = await response.text();\n    console.log(`[Stream Video Saver] M3U8 content length: ${text.length} chars`);\n    console.log(`[Stream Video Saver] M3U8 content preview (first 500 chars): ${text.substring(0, 500)}`);\n\n    // Extract filename for display\n    const urlObj = new URL(url.split('?')[0]);\n    const pathParts = urlObj.pathname.split('/');\n    const fileName = pathParts[pathParts.length - 1] || 'manifest.m3u8';\n\n    // Only process VOD (Video On Demand) playlists - skip master playlists and live streams\n    if (!text.includes('#EXT-X-PLAYLIST-TYPE:VOD')) {\n      console.log(`[Stream Video Saver] Skipping non-VOD manifest: ${fileName} (missing #EXT-X-PLAYLIST-TYPE:VOD)`);\n      return;\n    }\n\n    // Parse and store expected segment URLs immediately\n    const segmentUrls = parseM3U8(text, url);\n\n    // Only add to history if it has segments (additional safety check)\n    if (segmentUrls.length === 0) {\n      console.log(`[Stream Video Saver] Skipping manifest with no segments: ${fileName}`);\n      return;\n    }\n\n    // Double-check we don't already have this (race condition protection)\n    const duplicateCheck = manifestHistory.find((m) => {\n      const existingUrlWithoutQuery = m.m3u8Url.split('?')[0];\n      return existingUrlWithoutQuery === urlWithoutQuery;\n    });\n\n    if (duplicateCheck) {\n      console.log(`[Stream Video Saver] Duplicate detected during processing, skipping: ${fileName}`);\n      return;\n    }\n\n    // Try to get video title from the page\n    let title: string | undefined;\n\n    // First, try to get video title from content script\n    if (details.tabId && details.tabId > 0) {\n      try {\n        const videoTitleResponse = await chrome.tabs.sendMessage(details.tabId, { action: 'getVideoTitle' });\n        if (videoTitleResponse && videoTitleResponse.title) {\n          title = videoTitleResponse.title;\n          console.log(`[Stream Video Saver] Found video title from content script: ${title}`);\n        }\n      } catch (error) {\n        // Content script might not be available, continue to fallback\n        console.log('[Stream Video Saver] Could not get video title from content script, trying tab title');\n      }\n    }\n\n    // Fallback to tab title if video title not found\n    if (!title && details.tabId && details.tabId > 0) {\n      try {\n        const tab = await chrome.tabs.get(details.tabId);\n        if (tab && tab.title) {\n          title = tab.title;\n          console.log(`[Stream Video Saver] Using tab title: ${title}`);\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.log(`[Stream Video Saver] Could not get tab title: ${errorMessage}`);\n      }\n    }\n\n    // Create manifest object and add to history\n    const manifestId = generateManifestId();\n    const manifest: Manifest = {\n      id: manifestId,\n      m3u8Url: url,\n      m3u8Content: text,\n      m3u8FileName: fileName,\n      title: title,\n      expectedSegments: segmentUrls,\n      capturedAt: new Date().toISOString()\n    };\n\n    manifestHistory.push(manifest);\n\n    console.log(`[Stream Video Saver] \u2705 M3U8 captured and added to history: ${fileName}`);\n    console.log(`[Stream Video Saver] \uD83D\uDCCB Found ${segmentUrls.length} segments`);\n    console.log(`[Stream Video Saver] \uD83D\uDCDA Total manifests in history: ${manifestHistory.length}`);\n\n    if (segmentUrls.length > 0) {\n      console.log(`[Stream Video Saver] First few segments: ${segmentUrls.slice(0, 3)}`);\n    }\n\n    // Notify popup that a new manifest is available\n    chrome.runtime.sendMessage({\n      action: 'manifestCaptured',\n      manifestId: manifestId,\n      fileName: fileName,\n      title: title,\n      segmentCount: segmentUrls.length\n    } as ExtensionMessage).catch(() => {\n      // Ignore if no listeners\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(`[Stream Video Saver] Error fetching m3u8: ${errorMessage}`, error);\n  }\n}\n\n/**\n * Starts a download in the background script.\n * Creates a download ID, sets up abort controller, and initiates the ZIP download.\n * @param manifestId - The ID of the manifest to download\n * @param format - The download format (currently only 'zip' is supported)\n */\nasync function startDownload(manifestId: string, format: DownloadFormat): Promise<void> {\n  const downloadId = Date.now().toString(36) + Math.random().toString(36).slice(2);\n  const abortController = new AbortController();\n\n  // Find the manifest\n  const manifest = manifestHistory.find((m) => m.id === manifestId);\n  if (!manifest) {\n    notifyDownloadError(downloadId, 'Manifest not found');\n    return;\n  }\n\n  // Store download state\n  activeDownloads.set(downloadId, {\n    manifestId,\n    format,\n    cancelled: false,\n    abortController,\n    progress: { downloaded: 0, total: 0, status: 'starting' }\n  });\n\n  try {\n    if (format === 'zip') {\n      await downloadAsZip(downloadId, manifest, abortController.signal);\n    } else {\n      notifyDownloadError(downloadId, `Unsupported download format: ${format}`);\n      activeDownloads.delete(downloadId);\n      return;\n    }\n  } catch (error) {\n    if (!abortController.signal.aborted) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      notifyDownloadError(downloadId, errorMessage);\n    }\n    activeDownloads.delete(downloadId);\n  }\n}\n\n/**\n * Cancels an ongoing download.\n * Marks download as cancelled, aborts fetch requests, and removes from active downloads.\n * @param downloadId - The ID of the download to cancel\n */\nfunction cancelDownload(downloadId: string): void {\n  const download = activeDownloads.get(downloadId);\n  if (download) {\n    download.cancelled = true;\n    download.abortController.abort();\n    notifyDownloadProgress(downloadId, {\n      downloaded: download.progress.downloaded,\n      total: download.progress.total,\n      status: 'cancelled'\n    });\n    activeDownloads.delete(downloadId);\n    // Clear badge if no active downloads remain\n    if (activeDownloads.size === 0) {\n      chrome.action.setBadgeText({ text: '' });\n    }\n  }\n}\n\n/**\n * Sanitizes a string for use as a filename by removing invalid characters and limiting length.\n * @param name - The string to sanitize\n * @param maxLength - Maximum length for the filename (default: 200)\n * @returns Sanitized filename-safe string\n */\nfunction sanitizeFilename(name: string, maxLength: number = 200): string {\n  // Remove or replace invalid filename characters\n  let sanitized = name\n    .replace(/[<>:\"/\\\\|?*\\x00-\\x1f]/g, '') // Remove invalid characters\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n\n  // Limit length\n  if (sanitized.length > maxLength) {\n    sanitized = sanitized.substring(0, maxLength).trim();\n  }\n\n  // If empty after sanitization, return a default\n  if (!sanitized) {\n    return 'video';\n  }\n\n  return sanitized;\n}\n\n/**\n * Downloads video segments and packages them into a ZIP file.\n * Downloads segments in batches, creates ZIP archive, and triggers browser download.\n * @param downloadId - Unique identifier for this download\n * @param manifest - The manifest object containing m3u8 data and segment URLs\n * @param signal - AbortSignal to cancel the download\n * @throws Error If JSZip is not loaded or no segments are found\n */\nasync function downloadAsZip(downloadId: string, manifest: Manifest, signal: AbortSignal): Promise<void> {\n  if (typeof JSZip === 'undefined') {\n    throw new Error('JSZip library not loaded');\n  }\n\n  const zip = new JSZip();\n\n  // Modify m3u8 content to use local filenames\n  const modifiedM3U8Content = modifyM3U8ForLocalFiles(manifest.m3u8Content, manifest.m3u8Url);\n\n  // Add m3u8 file\n  const m3u8FileName = manifest.m3u8Url.substring(manifest.m3u8Url.lastIndexOf('/') + 1).split('?')[0];\n  zip.file(m3u8FileName, modifiedM3U8Content);\n\n  // Create and add bash script for converting to MP4\n  const scriptTimestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  \n  // Use title if available, otherwise fall back to m3u8 filename\n  const videoBaseName = manifest.title \n    ? sanitizeFilename(manifest.title)\n    : (m3u8FileName.replace('.m3u8', '') || 'output');\n  const outputFileName = `${videoBaseName}-${scriptTimestamp}.mp4`;\n\n  // Load template from file at runtime\n  const templateUrl = chrome.runtime.getURL('templates/compile_video.sh.template');\n  const templateResponse = await fetch(templateUrl);\n  if (!templateResponse.ok) {\n    throw new Error(`Failed to load template: ${templateResponse.status}`);\n  }\n  let bashScriptContent = await templateResponse.text();\n\n  // Replace template placeholders with actual values\n  bashScriptContent = bashScriptContent\n    .replace('{{MANIFEST_FILE}}', m3u8FileName)\n    .replace('{{OUTPUT_FILE}}', outputFileName);\n  \n  zip.file('compile_video.sh', bashScriptContent);\n\n  // Parse m3u8 to get segment URLs\n  const segmentUrls = parseM3U8(manifest.m3u8Content, manifest.m3u8Url);\n\n  if (segmentUrls.length === 0) {\n    throw new Error('No segments found in m3u8 file');\n  }\n\n  // Parse m3u8 to get initialization segment URLs from #EXT-X-MAP tags\n  const initSegmentUrls = parseInitSegments(manifest.m3u8Content, manifest.m3u8Url);\n  console.log(`[Stream Video Saver] Found ${initSegmentUrls.length} initialization segment(s)`);\n\n  // Total includes both regular segments and init segments\n  const total = segmentUrls.length + initSegmentUrls.length;\n  let downloaded = 0;\n\n  // Update initial progress\n  notifyDownloadProgress(downloadId, {\n    downloaded: 0,\n    total,\n    status: 'downloading'\n  });\n\n  // Download initialization segments first (if any)\n  if (initSegmentUrls.length > 0) {\n    console.log('[Stream Video Saver] Downloading initialization segments...');\n    for (const url of initSegmentUrls) {\n      if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n        throw new Error('Download cancelled');\n      }\n\n      try {\n        const response = await fetch(url, { signal });\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        const blob = await response.blob();\n\n        // Extract filename\n        let fileName: string;\n        try {\n          if (url.startsWith('http://') || url.startsWith('https://')) {\n            const urlObj = new URL(url);\n            const pathParts = urlObj.pathname.split('/');\n            fileName = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'init.mp4';\n          } else {\n            const urlParts = url.split('?')[0].split('/');\n            fileName = urlParts[urlParts.length - 1] || 'init.mp4';\n          }\n          fileName = fileName.split('?')[0];\n        } catch (error) {\n          fileName = url.substring(url.lastIndexOf('/') + 1).split('?')[0] || 'init.mp4';\n        }\n\n        if (!fileName) {\n          throw new Error('Could not extract filename from init segment URL');\n        }\n\n        // JSZip accepts Blob directly according to official types\n        zip.file(fileName, blob);\n        downloaded++;\n\n        // Update progress\n        const download = activeDownloads.get(downloadId);\n        if (download) {\n          download.progress = { downloaded, total, status: 'downloading' };\n        }\n        notifyDownloadProgress(downloadId, {\n          downloaded,\n          total,\n          status: 'downloading'\n        });\n\n        console.log(`[Stream Video Saver] Downloaded init segment: ${fileName}`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        console.error(`[Stream Video Saver] Failed to download init segment ${url}:`, errorMessage);\n        throw new Error(`Failed to download initialization segment: ${errorMessage}`);\n      }\n    }\n  }\n\n  // Download segments in batches\n  const batchSize = 5;\n  for (let i = 0; i < segmentUrls.length; i += batchSize) {\n    // Check if cancelled\n    if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n      throw new Error('Download cancelled');\n    }\n\n    const batch = segmentUrls.slice(i, i + batchSize);\n\n    await Promise.all(batch.map(async (url) => {\n      if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n        return;\n      }\n\n      try {\n        const response = await fetch(url, { signal });\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        const blob = await response.blob();\n\n        // Extract filename\n        let fileName: string;\n        try {\n          if (url.startsWith('http://') || url.startsWith('https://')) {\n            const urlObj = new URL(url);\n            const pathParts = urlObj.pathname.split('/');\n            fileName = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'segment.ts';\n          } else {\n            const urlParts = url.split('?')[0].split('/');\n            fileName = urlParts[urlParts.length - 1] || 'segment.ts';\n          }\n          fileName = fileName.split('?')[0];\n        } catch (error) {\n          fileName = url.substring(url.lastIndexOf('/') + 1).split('?')[0] || 'segment.ts';\n        }\n\n        if (!fileName) {\n          throw new Error('Could not extract filename from URL');\n        }\n\n        // JSZip accepts Blob directly according to official types\n        zip.file(fileName, blob);\n        downloaded++;\n\n        // Update progress\n        const download = activeDownloads.get(downloadId);\n        if (download) {\n          download.progress = { downloaded, total, status: 'downloading' };\n        }\n        notifyDownloadProgress(downloadId, {\n          downloaded,\n          total,\n          status: 'downloading'\n        });\n      } catch (error) {\n        if (error instanceof Error && error.name === 'AbortError') {\n          throw error;\n        }\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.error(`[Stream Video Saver] Error downloading segment ${url}:`, errorMessage);\n      }\n    }));\n  }\n\n  // Check if cancelled before creating zip\n  if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n    throw new Error('Download cancelled');\n  }\n\n  // Generate zip file - notify user that ZIP creation is starting\n  notifyDownloadProgress(downloadId, {\n    downloaded,\n    total,\n    status: 'creating_zip'\n  });\n\n  // Generate ZIP as ArrayBuffer (service workers don't support Blob/URL.createObjectURL)\n  // This can take a while for large files\n  const zipArrayBuffer = await zip.generateAsync({ type: 'arraybuffer', compression: 'DEFLATE' });\n\n  // Check if cancelled after ZIP generation\n  if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n    throw new Error('Download cancelled');\n  }\n\n  // Keep status as 'creating_zip' during base64 conversion as well\n  // This is still part of preparing the file for download\n  // Convert ArrayBuffer to base64 data URL for chrome.downloads API\n  // Use chunked conversion to avoid stack overflow with large files\n  const bytes = new Uint8Array(zipArrayBuffer);\n  let binary = '';\n  const chunkSize = 8192; // Process in 8KB chunks\n  const totalChunks = Math.ceil(bytes.length / chunkSize);\n  let processedChunks = 0;\n  \n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    // Check for cancellation periodically during conversion\n    if (signal.aborted || activeDownloads.get(downloadId)?.cancelled) {\n      throw new Error('Download cancelled');\n    }\n    \n    const chunk = bytes.subarray(i, i + chunkSize);\n    binary += String.fromCharCode.apply(null, Array.from(chunk));\n    processedChunks++;\n    \n    // Update progress periodically during base64 conversion (every 10% or every 100 chunks)\n    if (processedChunks % Math.max(1, Math.floor(totalChunks / 10)) === 0 || processedChunks === totalChunks) {\n      notifyDownloadProgress(downloadId, {\n        downloaded,\n        total,\n        status: 'creating_zip'\n      });\n    }\n  }\n  const base64 = btoa(binary);\n  const dataUrl = `data:application/zip;base64,${base64}`;\n\n  // Create download using chrome.downloads API\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n  // Use title if available, otherwise fall back to m3u8 filename\n  const zipBaseName = manifest.title\n    ? sanitizeFilename(manifest.title)\n    : (manifest.m3u8FileName.replace('.m3u8', '') || 'video');\n  const zipFileName = `${zipBaseName}-${timestamp}.zip`;\n\n  chrome.downloads.download({\n    url: dataUrl,\n    filename: zipFileName,\n    saveAs: true\n  }, (_chromeDownloadId?: number) => {\n    if (chrome.runtime.lastError) {\n      const errorMessage = chrome.runtime.lastError.message || 'Unknown error';\n      notifyDownloadError(downloadId, errorMessage);\n      activeDownloads.delete(downloadId);\n    } else {\n      notifyDownloadProgress(downloadId, {\n        downloaded,\n        total,\n        status: 'complete'\n      });\n      // Clean up after a short delay\n      setTimeout(() => {\n        activeDownloads.delete(downloadId);\n        // Clear badge if no active downloads remain\n        if (activeDownloads.size === 0) {\n          chrome.action.setBadgeText({ text: '' });\n        }\n      }, 2000);\n    }\n  });\n}\n\n/**\n * Modifies m3u8 content to use local filenames instead of full URLs.\n * Extracts just the filename from each segment URL line while preserving comments and metadata.\n * Also updates #EXT-X-MAP URI attributes to use local filenames.\n * @param content - The original m3u8 file content\n * @param baseUrl - The base URL of the m3u8 file (used for parsing relative URLs)\n * @returns Modified m3u8 content with local filenames\n */\nfunction modifyM3U8ForLocalFiles(content: string, _baseUrl: string): string {\n  const lines = content.split('\\n');\n  const modifiedLines: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmedLine = line.trim();\n\n    // Handle #EXT-X-MAP tags - update URI to use local filename\n    if (trimmedLine.startsWith('#EXT-X-MAP:')) {\n      const uriMatch = trimmedLine.match(/URI=\"([^\"]+)\"/);\n      if (uriMatch && uriMatch[1]) {\n        const uri = uriMatch[1];\n        let filename: string;\n\n        try {\n          // Extract filename from URI\n          if (uri.startsWith('http://') || uri.startsWith('https://')) {\n            const url = new URL(uri);\n            const pathParts = url.pathname.split('/');\n            filename = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'init.mp4';\n          } else if (uri.startsWith('/')) {\n            const pathParts = uri.split('/');\n            filename = pathParts[pathParts.length - 1] || 'init.mp4';\n          } else {\n            const urlParts = uri.split('?')[0].split('/');\n            filename = urlParts[urlParts.length - 1] || 'init.mp4';\n          }\n\n          if (filename) {\n            filename = filename.split('?')[0];\n            // Replace the URI in the tag with just the filename\n            const modifiedLine = trimmedLine.replace(/URI=\"[^\"]+\"/, `URI=\"${filename}\"`);\n            modifiedLines.push(modifiedLine);\n            console.log(`[Stream Video Saver] Updated #EXT-X-MAP URI: ${uri} -> ${filename}`);\n            continue;\n          }\n        } catch (error) {\n          console.warn(`[Stream Video Saver] Failed to parse init segment URI: ${uri}`, error);\n        }\n      }\n      // If we couldn't parse it, keep the original line\n      modifiedLines.push(line);\n      continue;\n    }\n\n    // Keep other comments and empty lines as-is\n    if (!trimmedLine || trimmedLine.startsWith('#')) {\n      modifiedLines.push(line);\n      continue;\n    }\n\n    // This is a segment URL line - extract just the filename\n    try {\n      let filename: string;\n\n      // If it's a full URL, parse it\n      if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {\n        const url = new URL(trimmedLine);\n        const pathParts = url.pathname.split('/');\n        filename = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'segment.ts';\n      } else if (trimmedLine.startsWith('/')) {\n        const pathParts = trimmedLine.split('/');\n        filename = pathParts[pathParts.length - 1] || 'segment.ts';\n      } else {\n        const urlParts = trimmedLine.split('?')[0].split('/');\n        filename = urlParts[urlParts.length - 1] || 'segment.ts';\n      }\n\n      if (!filename) {\n        modifiedLines.push(line);\n        continue;\n      }\n\n      filename = filename.split('?')[0];\n      modifiedLines.push(filename);\n    } catch (error) {\n      modifiedLines.push(line);\n    }\n  }\n\n  return modifiedLines.join('\\n');\n}\n\n/**\n * Updates the extension badge to show download progress.\n * @param progress - Progress information object\n */\nfunction updateBadge(progress: DownloadProgress): void {\n  if (progress.status === 'complete' || progress.status === 'cancelled') {\n    // Clear badge when download is complete or cancelled\n    chrome.action.setBadgeText({ text: '' });\n  } else {\n    // Show percentage on badge\n    const percent = Math.round((progress.downloaded / progress.total) * 100);\n    chrome.action.setBadgeText({ text: `${percent}%` });\n    chrome.action.setBadgeBackgroundColor({ color: '#4caf50' });\n  }\n}\n\n/**\n * Sends download progress update to the popup and updates the extension badge.\n * @param downloadId - The ID of the download\n * @param progress - Progress information object\n */\nfunction notifyDownloadProgress(downloadId: string, progress: DownloadProgress): void {\n  // Update extension badge\n  updateBadge(progress);\n\n  // Send message to popup\n  chrome.runtime.sendMessage({\n    action: 'downloadProgress',\n    downloadId,\n    ...progress\n  } as ExtensionMessage).catch(() => {\n    // Ignore if no listeners\n  });\n}\n\n/**\n * Sends download error notification to the popup and clears the badge.\n * @param downloadId - The ID of the download that failed\n * @param error - Error message describing what went wrong\n */\nfunction notifyDownloadError(downloadId: string, error: string): void {\n  // Clear badge on error\n  chrome.action.setBadgeText({ text: '' });\n\n  // Send message to popup\n  chrome.runtime.sendMessage({\n    action: 'downloadError',\n    downloadId,\n    error\n  } as ExtensionMessage).catch(() => {\n    // Ignore if no listeners\n  });\n}\n\n"],
  "mappings": "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",
  "names": []
}
